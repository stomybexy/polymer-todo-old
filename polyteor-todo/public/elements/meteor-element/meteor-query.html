<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../../bower_components/polymer/polymer.html">

<dom-module id="meteor-query">
    <script>
(function () {
    'use strict';

    Polymer({
        is: 'meteor-query',
        properties: {
            data: {
                type: Array,
                value: function () {
                    return [];
                },
                notify: true
            },

            query: {
                type: Object,
                notify: true,
                observer: '_onQueryChanged'
            }
        },
        observers: [
            '_dataChanged(data.*)',
        ],
        created: function () {

            this._receivingRemoteChanges = false;
            this._receivingLocalChanges = false;
            this._unsuppportedPath = [];
            this._handles = [];

        },
        ready: function () {

        },
        attached: function () {
            console.log('meteor-query was attached');
        },

        detached: function () {
            console.log('meteor-query was detached');
            
        },
        _onQueryChanged: function () {
            console.log('Query changed', this.query);
            this._stopHandles();
            this._runQuery();
        },
        _stopHandles: function () {
            _.each(this._handles, function (handle) {
                handle.stop();
            });
        },
        _runQuery: function () {

            var self = this;
            self._unsupportedPath = _.pluck(self.query.children, 'name');
            console.log('Unsupported path', self._unsupportedPath);
            var opt = self.query.find();
            var cursor = Mongo.Collection.get(self.query.collName)
                .find(opt.selector || {}, {
                    sort: opt.sort,
                    fields: opt.fields,
                    transform: function (doc) {
                        if (_.isFunction(opt.transform)) {
                            doc = opt.transform(doc);
                        }
                        _.each(self.query.children, (child) => {
                            self._attachChild.call(self, child, doc)
                        })
                        return doc;
                    }
                });
            self.data = cursor.fetch();
            // Tracker.autorun(function () {

            var handle = cursor.observe({
                addedAt: function (doc, atIndex, before) {
                    if (self.data.length === cursor.count()) {
                        return;
                    }
                    self._receivingRemoteChanges = true;
                    self.splice('data', atIndex, 0, doc);
                    self._receivingRemoteChanges = false;

                },
                changedAt: function (newDoc, oldDoc, atIndex) {

                    self._receivingRemoteChanges = true;
                    self.splice('data', atIndex, 1, newDoc);

                    self._receivingRemoteChanges = false;
                },
                removedAt: function (oldDoc, atIndex) {
                    self._receivingRemoteChanges = true;
                    self.splice('data', atIndex, 1);
                    self._receivingRemoteChanges = false;
                },
                movedTo: function (doc, fromIndex, toIndex, before) {
                    self._receivingRemoteChanges = true;
                    self.splice('data', fromIndex, 1);
                    self.splice('data', toIndex, 0, doc);

                    self._receivingRemoteChanges = false;
                }
            })
            this._handles.push(handle);
            // })
        },
        _attachChild: function (query, obj) {
            var self = this;
            var args = [].slice.call(arguments);
            args.splice(0, 1, obj);
            var opt = query.find.apply(this, args)
            var cursor = Mongo.Collection.get(query.collName)
                .find(opt.selector || {}, {
                    sort: opt.sort,
                    fields: opt.fields,
                    transform: function (doc) {
                        if (_.isFunction(opt.transform)) {
                            doc = opt.transform(doc);
                        }
                        _.each(query.children, (child) => {
                            args.splice(0, 0, child, doc);
                            self._attachChild.aplly(self, args);
                        })
                        return doc;
                    }
                })
            obj[query.name] = query.single ? cursor.fetch()[0] : cursor.fetch();
            // Tracker.autorun(function () {
            var handle;
            if (query.single) {
                handle = cursor.observe({
                    added: function (doc) {
                        if (obj[query.name]) {
                            return;
                        }
                        obj[query.name] = doc;
                    },
                    changed: function (doc) {
                        obj[query.name] = doc;

                    },
                    removed: function (doc) {
                        obj[query.name] = undefined;
                    }
                })
            } else {
                handle = cursor.observe({
                    addedAt: function (doc, atIndex, before) {

                        if (obj[query.name].length === cursor.count()) {
                            return;
                        }

                        obj[query.name].splice(atIndex, 0, doc);


                    },
                    changedAt: function (newDoc, oldDoc, atIndex) {


                        console.log('Changed from children...', newDoc, atIndex)
                        obj[query.name].splice(atIndex, 1, newDoc);

                    },
                    removedAt: function (oldDoc, atIndex) {

                        obj[query.name].splice(atIndex, 1);

                    },
                    movedTo: function (doc, fromIndex, toIndex, before) {

                        obj[query.name].splice(fromIndex, 1);
                        obj[query.name].splice(toIndex, 0, doc);

                    }

                })
            }
            this._handles.push(handle);
            // })


        },
        _dataChanged: function (change) {
            if (this._receivingRemoteChanges || this._receivingLocalChanges) {
                return;
            }
            console.log('data changed', change);
            this._localDataChanged(change);
        },
        _localDataChanged(change) {
            var pathParts = change.path.split('.');
            // We don't care about self-changes, and we don't respond directly to
            // length changes:
            if (pathParts.length < 2 || pathParts[1] === 'length') {
                return;
            }
            // Handle splices via the adoption process. `indexSplices` is known to
            // sometimes be null, so guard against that.
            if (pathParts[1] === 'splices') {
                // this._adoptSplices(change.value.indexSplices);
                return;
            }
            // Otherwise, the change is happening to a sub-path of the array.
            this._applySubPathChange(change);

        },
        _applySubPathChange: function (change) {
            var path = change.path.split('.');

            var key = path[1];
            path.splice(0, 2);

            if (_.contains(this._unsupportedPath, path[0])) {
                return console.log('Unspported path for autoupdate', path[0]);
            }

            var remoteKey = path.join('.');
            console.log('key', key)
            console.log('remote key', remoteKey);

            if (remoteKey.indexOf('#') > -1) {
                return console.log('Unsupported autoupdate with this path. Update manually');
            }

            var value = Polymer.Collection.get(change.base).getItem(key);
            console.log('doc changed', value)

            var setModifier = {};


            setModifier[remoteKey] = change.value;
            console.log(setModifier);
            var res = Mongo.Collection.get(this.query.collName).update({
                _id: value._id
            }, {
                    $set: setModifier
                })
            console.log('result of update', res);
        }
    });
})();
    </script>
</dom-module>